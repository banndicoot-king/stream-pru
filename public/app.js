/**
 *
 * CODE BY AJAY OS [https://github.com/Ajayos]
 *
 * üéß Streaming Application
 * Handles UI interactions, audio streaming, WebSocket messaging, and file uploads üöÄ
 */
class StreamingApp {
  constructor() {
    // üìä Application state variables
    this.state = {
      messageCount: 0, // üì® Total console messages
      audioPacketCount: 0, // üéµ Audio packets received
      wsMessageCount: 0, // üì° WebSocket messages
      fileUploadCount: 0, // üìÇ File upload logs
      currentTab: "events", // üñ•Ô∏è Current log tab
      selectedFiles: [], // üìë Selected files for upload
      currentStream: null, // üì∫ Active stream ID
      rooms: [], // üè† Available rooms
      currentRoomRequest: null, // üôã Room request popup
      popupTimeout: null, // ‚è±Ô∏è Timeout for popups
      chunkSize: 64 * 1024, // üì¶ Default upload chunk size (64 KB)
    };

    // üéµ Initialize audio context
    this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    this.playTime = this.audioCtx.currentTime;

    // üìí Log storage
    this.logs = {
      events: [],
      websocket: [],
      audio: [],
      files: [],
    };

    // üîå Initialize WebSocket client
    this.wsClient = new WebSocketClient();

    // üìÅ Cache DOM elements
    this.elements = {};

    // üöÄ Initialize app
    this.init();
  }

  /**
   * üöÄ Initialize app and setup listeners
   */
  init() {
    this.cacheElements(); // üìÅ Cache DOM
    this.setupEventListeners(); // üéõÔ∏è Attach UI listeners
    this.setupWebSocketHandlers(); // üì° WS handlers
    this.updateUI(); // üîÑ Initial UI update

    // üîå Connect WebSocket
    this.wsClient.connect();

    this.logToConsole(
      "success",
      "‚úÖ Application initialized successfully",
      null,
      "events"
    );
  }

  /**
   * üóÇÔ∏è Cache DOM elements for quick access (with line-by-line emojis and comments)
   */
  cacheElements() {
    this.elements = {
      // üéõÔ∏è Stream controls
      streamSelect: document.getElementById("streamSelect"), // üîΩ Stream dropdown
      currentStreamName: document.getElementById("currentStreamName"), // üè∑Ô∏è Current stream name
      clearStreamBtn: document.getElementById("clearStreamBtn"), // ‚ùå Clear stream button
      markStreamBtn: document.getElementById("markStreamBtn"), // üè∑Ô∏è Mark stream button

      // üü¢ Status indicators
      connectionStatus: document.getElementById("connectionStatus"), // üü¢ Main status dot
      connectionStatus2: document.getElementById("connectionStatus2"), // üü¢ Secondary status dot
      statusText: document.getElementById("statusText"), // üìù Status text
      audioStatus: document.getElementById("audioStatus"), // üéµ Audio status text
      inDot: document.getElementById("inDot"), // ‚¨ÖÔ∏è Incoming dot
      outDot: document.getElementById("outDot"), // ‚û°Ô∏è Outgoing dot

      // üìä Statistics
      streamCount: document.getElementById("streamCount"), // #Ô∏è‚É£ Stream count
      messageCount: document.getElementById("messageCount"), // #Ô∏è‚É£ Message count
      audioPackets: document.getElementById("audioPackets"), // #Ô∏è‚É£ Audio packets
      wsMessages: document.getElementById("wsMessages"), // #Ô∏è‚É£ WebSocket messages
      fileUploadCount: document.getElementById("fileUploadCount"), // #Ô∏è‚É£ File upload count

      // üìÇ File handling
      fileInput: document.getElementById("fileInput"), // üìÅ File input
      fileInputDisplay: document.getElementById("fileInputDisplay"), // üñºÔ∏è File input display
      fileName: document.getElementById("fileName"), // üè∑Ô∏è File name display
      clearBtn: document.getElementById("clearBtn"), // ‚ùå Clear files button
      doneBtn: document.getElementById("doneBtn"), // ‚úÖ Done/upload button
      uploadProgress: document.getElementById("uploadProgress"), // üìä Upload progress bar container
      uploadProgressBar: document.getElementById("uploadProgressBar"), // üìà Upload progress bar

      // üîä Audio elements
      player: document.getElementById("player"), // ‚ñ∂Ô∏è Audio player
      callTone: document.getElementById("callTone"), // üìû Call tone audio

      // üñ•Ô∏è Console
      consoleContent: document.getElementById("consoleContent"), // üìù Console log area
      clearConsoleBtn: document.getElementById("clearConsoleBtn"), // üßπ Clear console button
      exportLogsBtn: document.getElementById("exportLogsBtn"), // üì§ Export logs button

      // ü™ü Popups
      roomPopupOverlay: document.getElementById("roomPopupOverlay"), // ü™ü Room popup overlay
      roomPopup: document.getElementById("roomPopup"), // ü™ü Room popup
      roomPopupName: document.getElementById("roomPopupName"), // üè∑Ô∏è Room popup name
      roomPopupDetails: document.getElementById("roomPopupDetails"), // üìù Room popup details
      acceptRoomBtn: document.getElementById("acceptRoomBtn"), // ‚úÖ Accept room button
      declineRoomBtn: document.getElementById("declineRoomBtn"), // ‚ùå Decline room button

      // ‚öôÔ∏è Upload settings popup
      uploadSettingsOverlay: document.getElementById("uploadSettingsOverlay"), // ü™ü Upload settings overlay
      uploadSettingsPopup: document.getElementById("uploadSettingsPopup"), // ü™ü Upload settings popup
      uploadSettingsBtn: document.getElementById("uploadSettingsBtn"), // ‚öôÔ∏è Open upload settings button
      packetSize: document.getElementById("packetSize"), // üì¶ Packet size input
      submitUploadSettingsBtn: document.getElementById(
        "submitUploadSettingsBtn"
      ), // ‚úÖ Submit upload settings
      cancelUploadSettingsBtn: document.getElementById(
        "cancelUploadSettingsBtn"
      ), // ‚ùå Cancel upload settings
    };
  }

  /**
   * üñ±Ô∏è Setup UI event listeners
   */
  setupEventListeners() {
    // üéõÔ∏è Stream controls
    this.elements.streamSelect.addEventListener("change", (e) =>
      this.handleStreamSelection(e.target.value)
    );
    this.elements.clearStreamBtn.addEventListener("click", () =>
      this.clearStream()
    );
    this.elements.markStreamBtn.addEventListener("click", () =>
      this.markStream()
    );

    // üìÇ File handling
    this.elements.fileInput.addEventListener("change", (e) =>
      this.handleFileSelection(e.target.files)
    );
    this.elements.clearBtn.addEventListener("click", () =>
      this.clearFileSelection()
    );
    this.elements.doneBtn.addEventListener("click", () => this.uploadFiles());

    // üéµ Audio status
    this.elements.player.addEventListener("play", () =>
      this.updateAudioStatus("‚ñ∂Ô∏è Playing Audio")
    );
    this.elements.player.addEventListener("pause", () =>
      this.updateAudioStatus("‚è∏Ô∏è Paused")
    );
    this.elements.player.addEventListener("ended", () =>
      this.updateAudioStatus("‚èπÔ∏è Ended")
    );

    // üñ•Ô∏è Console actions
    this.elements.clearConsoleBtn.addEventListener("click", () =>
      this.clearConsole()
    );
    this.elements.exportLogsBtn.addEventListener("click", () =>
      this.exportLogs()
    );

    // üìë Console tabs
    document.querySelectorAll(".console-tab").forEach((tab) => {
      tab.addEventListener("click", () => this.switchTab(tab.dataset.tab));
    });

    // üîî Popup buttons
    this.elements.acceptRoomBtn.addEventListener("click", () =>
      this.acceptRoomRequest()
    );
    this.elements.declineRoomBtn.addEventListener("click", () =>
      this.dismissRoomPopup()
    );
    this.elements.uploadSettingsBtn.addEventListener("click", () =>
      this.openUploadSettings()
    );
    this.elements.submitUploadSettingsBtn.addEventListener("click", () =>
      this.submitUploadSettings()
    );
    this.elements.cancelUploadSettingsBtn.addEventListener("click", () =>
      this.dismissUploadSettings()
    );

    // üñ±Ô∏è Overlay close
    this.elements.roomPopupOverlay.addEventListener("click", (e) => {
      if (e.target === this.elements.roomPopupOverlay) this.dismissRoomPopup();
    });
    this.elements.uploadSettingsOverlay.addEventListener("click", (e) => {
      if (e.target === this.elements.uploadSettingsOverlay)
        this.dismissUploadSettings();
    });

    // ‚å®Ô∏è Keyboard escape
    document.addEventListener("keydown", (e) => this.handleKeydown(e));

    // üö™ Cleanup before exit
    window.addEventListener("beforeunload", () => this.cleanup());
  }

  /**
   * üì° Setup WebSocket event handlers
   */
  setupWebSocketHandlers() {
    this.wsClient.on("connected", (data) => {
      this.updateConnectionStatus(true);
      this.logToConsole(
        "success",
        "‚úÖ WebSocket connection established",
        data,
        "events"
      );
      this.logToConsole("websocket", "üì° Connection opened", data, "websocket");
      this.blinkIODot("out");
    });

    this.wsClient.on("disconnected", (data) => {
      this.updateConnectionStatus(false);
      this.logToConsole("warning", "‚ö†Ô∏è WebSocket disconnected", data, "events");
      this.logToConsole("websocket", "üì° Connection closed", data, "websocket");
    });

    this.wsClient.on("error", (data) => {
      this.logToConsole("error", "‚ùå WebSocket error", data, "events");
      this.logToConsole("websocket", "üî¥ WebSocket error", data, "websocket");
      this.updateConnectionStatus(false);
    });

    this.wsClient.on("messageIn", (data) => {
      this.blinkIODot("in");
      this.logToConsole(
        "websocket",
        `‚¨ÖÔ∏è Received: ${data.type}`,
        data.payload,
        "websocket"
      );
    });

    this.wsClient.on("messageOut", (data) => {
      this.blinkIODot("out");
      this.logToConsole(
        "websocket",
        `‚û°Ô∏è Sent: ${data.type}`,
        data.payload,
        "websocket"
      );
    });

    this.wsClient.on("streamsAdded", (data) => {
      this.handleStreamsAdded(data);
    });

    this.wsClient.on("streamRemoved", (data) => {
      this.handleStreamRemoved(data);
    });

    this.wsClient.on("dtmf", (data) => {
      this.handleDtmf(data);
    });

    this.wsClient.on("audioData", (data) => {
      this.handleAudioData(data);
    });

    this.wsClient.on("fileUploadResponse", (data) => {
      this.handleFileUploadResponse(data);
    });

    this.wsClient.on("serverError", (data) => {
      this.logToConsole(
        "error",
        `‚ùå Server error: ${data.error}`,
        data,
        "events"
      );
      this.showToast(`‚ùå Server error: ${data.error}`, "error");
    });
  }

  /**
   * üé• Handle streams added
   */
  handleStreamsAdded(data) {
    // üè† Add new streams to state.rooms array
    this.state.rooms = [...this.state.rooms, ...data.stream];

    // üîÅ Loop through each new stream
    data.stream.forEach((room) => {
      // üÜî If room.id is undefined, set it from room.room_id
      if (room.id === undefined) {
        room.id = room.room_id;
        // ü™ü Show room request popup for new room
        this.showRoomRequestPopup({
          ...room,
          requester: room.requester || "Anonymous User", // üë§ Default requester
          timestamp: new Date().toISOString(), // üïí Current time
        });
      }
    });

    // üîÑ Update stream dropdown UI
    this.updateStreamList();

    // üìù Log added streams to console
    this.logToConsole(
      "success", // ‚úÖ Log type
      ` Added ${data.stream.length} stream(s)`, // üìù Message
      data.stream, // üì¶ Data
      "events" // üñ•Ô∏è Log tab
    );
  }

  handleDtmf(data) {
    // log the data.dtmf.digit
    console.log("DTMF digit received:", data.dtmf.digit);
    this.showToast(`DTMF digit received: ${data.dtmf.digit} `, "info");
    this.logToConsole(
      "success", // ‚úÖ Log type
      `DTMF digit received: ${data.dtmf.digit} `, // üìù Message
      data, // üì¶ Data
      "events" // üñ•Ô∏è Log tab
    );
  }

  /**
   * üé• Handle stream removed (with line-by-line emojis and comments)
   */
  handleStreamRemoved(data) {
    // üÜî Extract room ID from data
    const roomId = data?.room_id;
    if (!roomId) {
      // ‚ùå Log error if room ID is missing
      this.logToConsole(
        "error",
        "‚ùå Invalid room ID in remove-stream message",
        data,
        "events"
      );
      return; // ‚èπÔ∏è Stop further processing
    }

    // üîî Show toast notification with reason
    this.showToast(`${data.reason}`, "error");

    // üóëÔ∏è Remove the room from state.rooms array
    this.state.rooms = this.state.rooms.filter((room) => room.id !== roomId);

    // ‚èπÔ∏è If the removed room is the current stream, stop streaming
    if (this.state.currentStream === roomId) {
      this.stopStreaming();
    }

    // üîÑ Update the stream dropdown UI
    this.updateStreamList();

    // üìù Log the removed stream to console
    this.logToConsole(
      "warning", // ‚ö†Ô∏è Log type
      `üóëÔ∏è Removed stream: ${roomId}`, // üìù Message
      null, // üì¶ No extra data
      "events" // üñ•Ô∏è Log tab
    );
  }

  /**
   * üé• Handle audio data
   */
  handleAudioData(data) {
    // üìù Log audio chunk received to console
    this.logToConsole(
      "audio", // üéµ Log type
      "PCM audio chunk received", // üìù Message
      {
        chunk: data.media?.chunk || "", // üß© Chunk identifier
        size: data.media?.payload ? data.media.payload.length : "unknown", // üìè Payload size
      },
      "audio" // üéµ Log tab
    );

    // ‚è±Ô∏è If testtime is present, log delay info
    if (data.media?.testtime) {
      this.logDelayInfo(data.media.testtime);
    }

    // üîä Decode and play PCM audio chunk
    this.handlePCMAudioChunk(data.media);
  }

  /**
   * üìù Log delay information
   */
  logDelayInfo(testtimeStr) {
    // üßÆ Compute delay using testtime string
    const { streamerTs, now, delayMs } = this.computeDelayIST(testtimeStr);

    if (streamerTs) {
      // üìù Log delay info to console
      this.logToConsole(
        "audio", // üéµ Log type
        `Stream delay: ${delayMs} ms\n` + // ‚è±Ô∏è Delay in ms
          `[Client received: ${now.toISOString()}]\n` + // üïí Client receive time
          `[Streamer sent (IST raw): ${testtimeStr}]\n` + // üïí Raw IST string
          `[Parsed IST: ${streamerTs.toLocaleString("en-IN", {
            timeZone: "Asia/Kolkata",
          })}]`, // üóìÔ∏è Parsed IST time
        {
          delayMs, // ‚è±Ô∏è Delay in ms
          clientReceiveTs: now.getTime(), // üïí Client receive timestamp
          streamerTs: streamerTs.getTime(), // üïí Streamer send timestamp
        },
        "audio" // üéµ Log tab
      );
    } else {
      // ‚ö†Ô∏è Warn if testtime could not be parsed
      console.warn("Could not parse testtime:", testtimeStr);
    }
  }

  /**
   * üßÆ Compute delay from IST testtime (with line-by-line emojis and comments)
   */
  computeDelayIST(testtimeStr) {
    // üïí Parse the IST testtime string to a Date object
    const streamerTs = this.parseISTTestTime(testtimeStr);
    if (!streamerTs) {
      // ‚ùå Return nulls if parsing failed
      return { streamerTs: null, now: new Date(), delayMs: null };
    }

    // üï∞Ô∏è Get current client time
    const now = new Date();
    // ‚è±Ô∏è Calculate delay in milliseconds
    const delayMs = now.getTime() - streamerTs.getTime();

    // üì¶ Return computed values
    return { streamerTs, now, delayMs };
  }

  /**
   * üï∞Ô∏è Parse IST testtime string (with line-by-line emojis and comments)
   */
  parseISTTestTime(str) {
    // üîé Check if input string is valid and long enough
    if (!str || str.length < 17) return null;

    // üìÖ Parse year, month, day
    const year = parseInt(str.slice(0, 4), 10); // üóìÔ∏è Year
    const month = parseInt(str.slice(4, 6), 10) - 1; // üóìÔ∏è Month (0-based)
    const day = parseInt(str.slice(6, 8), 10); // üóìÔ∏è Day

    // üïí Parse hour, minute, second
    const hour = parseInt(str.slice(8, 10), 10); // üïó Hour
    const minute = parseInt(str.slice(10, 12), 10); // üïß Minute
    const second = parseInt(str.slice(12, 14), 10); // ‚è±Ô∏è Second

    // üï∞Ô∏è Parse milliseconds
    const millis = parseInt(str.slice(14, 17), 10); // ü™ô Milliseconds

    // ‚ùå Return null if any date part is invalid
    if (isNaN(year) || isNaN(month) || isNaN(day)) return null;

    // üìÜ Construct and return JS Date object
    return new Date(year, month, day, hour, minute, second, millis);
  }

  /**
   * üéõÔ∏è Handle stream selection (with line-by-line emojis and comments)
   */
  handleStreamSelection(selectedStream) {
    // üîÑ If the selected stream is different from the current one
    if (this.state.currentStream !== selectedStream) {
      // ‚èπÔ∏è If already in a stream, stop it first
      if (this.state.currentStream) {
        this.stopStreaming();
      }

      // üÜï Set the new current stream
      this.state.currentStream = selectedStream;

      // ‚úÖ If a stream is selected
      if (this.state.currentStream) {
        // üîç Find the selected room object by ID
        const selectedRoom = this.state.rooms.find(
          (room) => room.id === this.state.currentStream
        );
        // üè∑Ô∏è Update UI with stream name or fallback
        this.elements.currentStreamName.textContent = selectedRoom
          ? selectedRoom.name
          : "Unknown Stream";
        // üîì Enable clear and mark buttons
        this.elements.clearStreamBtn.disabled = false;
        this.elements.markStreamBtn.disabled = false;

        // ‚ñ∂Ô∏è Start streaming the selected room
        this.startStreaming();
        // üìù Log stream selection to console
        this.logToConsole(
          "info",
          `Selected stream: ${selectedRoom?.name || "Unknown"}`,
          selectedRoom,
          "events"
        );
      } else {
        // üö´ No stream selected, disable buttons and update UI
        this.elements.clearStreamBtn.disabled = true;
        this.elements.markStreamBtn.disabled = true;
        this.elements.currentStreamName.textContent = "No stream selected";
      }
    }
  }

  /**
   * Start streaming
   */
  startStreaming() {
    if (!this.state.currentStream || !this.wsClient.isConnected) return;

    this.logToConsole(
      "info",
      `Starting stream: ${this.state.currentStream}`,
      null,
      "events"
    );
    this.wsClient.joinRoom(this.state.currentStream);
    this.logToConsole(
      "success",
      `Joined room: ${this.state.currentStream}`,
      null,
      "events"
    );
  }

  /**
   * Stop streaming
   */
  stopStreaming() {
    if (this.state.currentStream) {
      this.wsClient.leaveRoom(this.state.currentStream);
      this.logToConsole(
        "info",
        `Left room: ${this.state.currentStream}`,
        null,
        "events"
      );

      this.state.currentStream = null;
      this.elements.clearStreamBtn.disabled = true;
      this.elements.markStreamBtn.disabled = true;
      this.elements.currentStreamName.textContent = "No stream selected";
    }
  }

  /**
   * Clear stream
   */
  clearStream() {
    if (this.wsClient.clearStream(this.state.currentStream)) {
      this.logToConsole(
        "info",
        `Sent clear audio to ${this.state.currentStream}`,
        null,
        "events"
      );
      this.showToast("Cleared audio stream", "info");
    }
  }

  /**
   * Mark stream
   */
  markStream() {
    if (this.wsClient.markStream(this.state.currentStream)) {
      this.logToConsole(
        "info",
        `Marked audio to ${this.state.currentStream}`,
        null,
        "events"
      );
      this.showToast("Marked audio stream", "info");
    }
  }

  // üéµ Decode + play PCM audio
  handlePCMAudioChunk(chunk, options = {}) {
    try {
      const {
        sampleRate = 8000,
        numChannels = 1,
        bitsPerSample = 16,
      } = options;

      if (!chunk.payload) throw new Error("Missing PCM payload");

      // üîë Decode base64 PCM ‚Üí Uint8Array
      const binary = atob(chunk.payload);
      const rawPCM = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) {
        rawPCM[i] = binary.charCodeAt(i);
      }

      const bytesPerSample = bitsPerSample / 8;
      const sampleCount = rawPCM.length / bytesPerSample;
      const audioBuffer = this.audioCtx.createBuffer(
        numChannels,
        sampleCount,
        sampleRate
      );

      // üìù Fill buffer (16-bit signed PCM ‚Üí float [-1,1])
      const channelData = audioBuffer.getChannelData(0);
      for (let i = 0; i < sampleCount; i++) {
        const sample = rawPCM[i * 2] | (rawPCM[i * 2 + 1] << 8);
        channelData[i] =
          sample < 0x8000 ? sample / 32768 : (sample - 65536) / 32768;
      }

      // üîä Create playback source
      const source = this.audioCtx.createBufferSource();
      source.buffer = audioBuffer;
      source.connect(this.audioCtx.destination);

      // üïí Status: Playing
      this.updateAudioStatus("‚ñ∂Ô∏è Playing Audio");

      // ‚è±Ô∏è Scheduling logic
      const now = this.audioCtx.currentTime;
      let gap = this.playTime - now;

      // üõ†Ô∏è Log scheduling gap
      this.logToConsole(
        "audio",
        `‚è±Ô∏è Audio scheduling: Current=${now.toFixed(
          3
        )} Playhead=${this.playTime.toFixed(3)} Gap=${gap.toFixed(3)} sec`,
        null,
        "audio"
      );

      // üéØ Target small buffer ahead (e.g. 0.1s)
      const targetLead = 0.1;

      // If too far ahead ‚Üí slowly pull back
      if (gap > targetLead + 0.3) {
        this.logToConsole(
          "warn",
          "‚ö†Ô∏è Too much buffered ahead, adjusting back smoothly.",
          null,
          "audio"
        );
        console.warn("‚ö†Ô∏è Too much buffered ahead, adjusting back smoothly.");
        this.playTime -= 0.2; // shift back slightly
      }

      // If underrun ‚Üí push forward closer to now
      if (gap < targetLead - 0.2) {
        this.logToConsole(
          "warn",
          "‚ö†Ô∏è Underrun detected, adjusting forward.",
          null,
          "audio"
        );
        console.warn("‚ö†Ô∏è Underrun detected, adjusting forward.");
        this.playTime = now + targetLead;
      }

      // ‚ñ∂Ô∏è Schedule playback
      source.start(this.playTime);

      // ‚èπÔ∏è Status: Ended when playback finishes
      source.onended = () => {
        this.updateAudioStatus("‚èπÔ∏è Ended");
      };

      this.playTime += audioBuffer.duration;
    } catch (err) {
      this.logToConsole("error", "‚ùå PCM chunk playback failed:", err);
      console.error("‚ùå PCM chunk playback failed:", err);
    }
  }

  /**
   * üìÇ Handle file selection from input
   */
  handleFileSelection(files) {
    // üóÇÔ∏è Convert FileList to array and store in state
    this.state.selectedFiles = Array.from(files);

    // üìù Update file display UI
    this.updateFileDisplay();

    // üéõÔ∏è Update action buttons (clear/done)
    this.updateActionButtons();

    // üìù Log file selection to console
    this.logToConsole(
      "files", // üìÅ Log type
      `üìÇ Selected ${this.state.selectedFiles.length} file(s)`, // üìù Message
      this.state.selectedFiles.map((f) => ({
        name: f.name, // üìÑ File name
        size: f.size, // üìè File size
        type: f.type, // üè∑Ô∏è File type
      })),
      "files" // üìÅ Log tab
    );
  }

  /**
   * üìë Update file display UI
   */
  updateFileDisplay() {
    // üì¶ Get display and file name elements
    const display = this.elements.fileInputDisplay;
    const fileName = this.elements.fileName;

    // üìÇ If files are selected
    if (this.state.selectedFiles.length > 0) {
      display.classList.add("has-file"); // ‚úÖ Highlight display
      if (this.state.selectedFiles.length === 1) {
        // üìù Show single file name
        fileName.textContent = this.state.selectedFiles[0].name;
      } else {
        // üóÉÔ∏è Show count for multiple files
        fileName.textContent = `${this.state.selectedFiles.length} files selected`;
      }
    } else {
      // ‚ùå No files selected, reset UI
      display.classList.remove("has-file");
      fileName.textContent = "";
    }
  }

  /**
   * üéõÔ∏è Update action buttons (clear/done)
   */
  updateActionButtons() {
    // üìÇ Check if any files are selected
    const hasFiles = this.state.selectedFiles.length > 0;

    // ‚ùå Enable/disable clear button
    this.elements.clearBtn.disabled = !hasFiles;

    // ‚úÖ Enable/disable done (upload) button
    this.elements.doneBtn.disabled = !hasFiles;
  }

  /**
   * ‚ùåüóÇÔ∏è Clear file selection
   */
  clearFileSelection() {
    // üóëÔ∏è Clear selected files array in state
    this.state.selectedFiles = [];
    // üßπ Reset file input element value
    this.elements.fileInput.value = "";
    // üîÑ Update file display UI
    this.updateFileDisplay();
    // üéõÔ∏è Update action buttons (clear/done)
    this.updateActionButtons();
    // üö´ Hide upload progress bar
    this.hideUploadProgress();
    // üìù Log file selection cleared to console
    this.logToConsole("files", "üóëÔ∏è File selection cleared", null, "files");
    // üîî Show toast notification
    this.showToast("üóëÔ∏è File selection cleared", "info");
  }

  /**
   * üì§ Upload files (with line-by-line emojis and comments)
   */
  async uploadFiles() {
    // üõë Check if files are selected, WebSocket is connected, and a stream is selected
    if (this.state.selectedFiles.length === 0) {
      this.logToConsole(
        "warning",
        "‚ùå No files selected for upload",
        null,
        "files"
      );
      this.showToast("No files selected", "warning");
      return;
    }
    if (!this.wsClient.isConnected) {
      this.logToConsole("warning", "‚ùå WebSocket not connected", null, "files");
      this.showToast("WebSocket not connected", "warning");
      return;
    }
    if (!this.state.currentStream) {
      this.logToConsole(
        "warning",
        "‚ùå No stream selected for upload",
        null,
        "files"
      );
      this.showToast("No stream selected", "warning");
      return;
    }

    // üìä Show upload progress bar
    this.showUploadProgress();

    // üîÅ Loop through each selected file
    for (let i = 0; i < this.state.selectedFiles.length; i++) {
      const file = this.state.selectedFiles[i]; // üìÑ Get file
      // ‚è´ Upload single file (await for sequential upload)
      await this.uploadSingleFile(file, i + 1, this.state.selectedFiles.length);
    }

    // ‚úÖ Hide upload progress bar after all uploads
    this.hideUploadProgress();
    // üéâ Show success toast
    this.showToast(
      `Successfully uploaded ${this.state.selectedFiles.length} file(s)`,
      "success"
    );
    // üßπ Clear file selection after upload
    this.clearFileSelection();
  }

  /**
   * üì§ Upload a single file in chunks as `media` events
   */
  async uploadSingleFile(file, index, total) {
    const totalChunks = Math.ceil(file.size / this.state.chunkSize);

    this.logToConsole(
      "files",
      `üì§ Uploading file: ${file.name} (${totalChunks} chunks)`,
      { name: file.name, size: file.size, type: file.type },
      "files"
    );

    let sequenceNumber = 0; // üî¢ keep track of sequence

    for (let chunkIndex = 0; chunkIndex < totalChunks; chunkIndex++) {
      const start = chunkIndex * this.state.chunkSize;
      const end = Math.min(start + this.state.chunkSize, file.size);
      const chunk = file.slice(start, end);

      const reader = new FileReader();
      reader.onload = (e) => {
        const arrayBuffer = e.target.result;

        // üõë Skip WAV header only for first chunk
        let dataBuffer = arrayBuffer;
        if (chunkIndex === 0) {
          const HEADER_SIZE = 44; // PCM16 WAV header
          dataBuffer = arrayBuffer.slice(HEADER_SIZE);
        }

        // üéµ Convert to PCM16
        const pcm = new Int16Array(dataBuffer); // 16-bit signed PCM assumption

        // üéöÔ∏è Normalize (optional: boost quiet voices)
        let maxAmp = 0;
        for (let i = 0; i < pcm.length; i++) {
          maxAmp = Math.max(maxAmp, Math.abs(pcm[i]));
        }
        const gain = maxAmp > 0 ? 32767 / maxAmp : 1; // scale to full range
        for (let i = 0; i < pcm.length; i++) {
          pcm[i] = Math.max(-32768, Math.min(32767, pcm[i] * gain));
        }

        // üî° Encode back to base64
        const uint8 = new Uint8Array(pcm.buffer);
        const base64Data = btoa(String.fromCharCode(...uint8));

        // üïí Timestamp (ms)
        const timestamp = Date.now();

        // üì¶ Wrap packet as "audio"
        const uploadData = {
          event: "audio",
          sequence_number: sequenceNumber++, // auto-increment
          room_id: this.state.currentStream,
          media: {
            chunk: chunkIndex,
            timestamp: timestamp,
            payload: base64Data,
          },
        };

        // üöÄ Send via WebSocket
        this.wsClient.send(JSON.stringify(uploadData));
      };

      reader.readAsArrayBuffer(chunk);

      // üìä Progress update
      const progress =
        (((index - 1) * totalChunks + chunkIndex + 1) / (total * totalChunks)) *
        100;
      this.updateUploadProgress(progress);

      // ‚è≥ Small pause to keep UI smooth
      await new Promise((resolve) => setTimeout(resolve, 10));
    }
  }

  /**
   * Handle file upload response
   */
  handleFileUploadResponse(response) {
    if (response.success) {
      this.logToConsole(
        "files",
        `File upload successful: ${response.fileName}`,
        response,
        "files"
      );
    } else {
      this.logToConsole(
        "files",
        `File upload failed: ${response.fileName} - ${response.error}`,
        response,
        "files"
      );
      this.showToast(`Upload failed: ${response.error}`, "error");
    }
  }

  /**
   * Show upload progress
   */
  showUploadProgress() {
    this.elements.uploadProgress.classList.add("show");
  }

  /**
   * Hide upload progress
   */
  hideUploadProgress() {
    this.elements.uploadProgress.classList.remove("show");
    this.updateUploadProgress(0);
  }

  /**
   * Update upload progress
   */
  updateUploadProgress(percentage) {
    this.elements.uploadProgressBar.style.width = `${percentage}%`;
  }

  /**
   * Update stream list
   */
  updateStreamList() {
    this.elements.streamSelect.innerHTML =
      '<option value="">Select a stream</option>';

    this.state.rooms.forEach((room) => {
      const option = document.createElement("option");
      option.value = room.id;
      option.textContent = room.name;
      if (this.state.currentStream === room.id) {
        option.selected = true;
      }
      this.elements.streamSelect.appendChild(option);
    });

    if (this.state.currentStream) {
      this.elements.streamSelect.value = this.state.currentStream;
    }

    this.elements.streamCount.textContent = this.state.rooms.length;
  }

  /**
   * Update connection status
   */
  updateConnectionStatus(connected) {
    if (connected) {
      this.elements.connectionStatus.classList.add("connected");
      this.elements.connectionStatus2.classList.add("connected");
      this.elements.statusText.textContent = "Connected";
    } else {
      this.elements.connectionStatus.classList.remove("connected");
      this.elements.connectionStatus2.classList.add("disconnected");
      this.elements.statusText.textContent = "Disconnected";
    }
  }

  /**
   * Update audio status
   */
  updateAudioStatus(status) {
    this.elements.audioStatus.textContent = status;
    if (status === "Playing Audio") {
      this.blinkDot2("audio");
    }
  }

  /**
   * Blink I/O dots
   */
  blinkIODot(direction) {
    const dot = this.elements[direction === "in" ? "inDot" : "outDot"];
    dot.classList.add("active");
    this.blinkDot2(direction === "in" ? "inDot" : "outDot");
    setTimeout(() => dot.classList.remove("active"), 300);
  }

  /**
   * Blink status dot 2
   */
  blinkDot2(dotId) {
    this.elements.connectionStatus2.classList.forEach((cls) => {
      if (cls !== "status-dot2") {
        this.elements.connectionStatus2.classList.remove(cls);
      }
    });
    this.elements.connectionStatus2.classList.add(dotId);
    setTimeout(
      () => this.elements.connectionStatus2.classList.remove(dotId),
      300
    );
  }

  /**
   * Show room request popup
   */
  showRoomRequestPopup(roomData) {
    if (this.state.currentStream) return; // Skip if already in a room

    this.state.currentRoomRequest = roomData;
    this.playCallTone();

    this.elements.roomPopupName.textContent = roomData.name || "Unknown Room";
    this.elements.roomPopupDetails.textContent = `Room ID: ${
      roomData.id || "N/A"
    }\nTime: ${new Date(roomData.timestamp).toLocaleString()}`;

    this.elements.roomPopupOverlay.classList.add("show");
    this.elements.roomPopup.classList.add("show");

    this.state.popupTimeout = setTimeout(() => this.dismissRoomPopup(), 15000);

    this.logToConsole(
      "events",
      `Room request popup shown: ${roomData.name}`,
      roomData,
      "events"
    );
  }

  /**
   * Accept room request
   */
  acceptRoomRequest() {
    if (this.state.currentRoomRequest) {
      this.elements.streamSelect.value = this.state.currentRoomRequest.id;
      this.handleStreamSelection(this.state.currentRoomRequest.id);

      this.logToConsole(
        "success",
        `Accepted room request: ${this.state.currentRoomRequest.name}`,
        this.state.currentRoomRequest,
        "events"
      );
      this.showToast(
        `Room "${this.state.currentRoomRequest.name}" accepted!`,
        "success"
      );
    }
    this.dismissRoomPopup();
  }

  /**
   * Dismiss room popup
   */
  dismissRoomPopup() {
    this.stopCallTone();
    this.elements.roomPopupOverlay.classList.remove("show");
    this.elements.roomPopup.classList.remove("show");

    if (this.state.popupTimeout) {
      clearTimeout(this.state.popupTimeout);
      this.state.popupTimeout = null;
    }

    setTimeout(() => {
      this.state.currentRoomRequest = null;
    }, 400);
  }

  /**
   * Play call tone
   */
  playCallTone() {
    this.elements.callTone.muted = false;
  }

  /**
   * Stop call tone
   */
  stopCallTone() {
    this.elements.callTone.muted = true;
    this.elements.callTone.currentTime = 0;
  }

  /**
   * Open upload settings
   */
  openUploadSettings() {
    this.elements.packetSize.value = this.state.chunkSize / 1024;
    this.elements.uploadSettingsOverlay.classList.add("show");
    this.elements.uploadSettingsPopup.classList.add("show");
  }

  /**
   * Submit upload settings
   */
  submitUploadSettings() {
    const newSize = parseInt(this.elements.packetSize.value);
    if (newSize > 0) {
      this.state.chunkSize = newSize * 1024;
      this.showToast(`Packet size set to ${newSize} KB`, "success");
      this.logToConsole(
        "info",
        `Updated packet size to ${newSize} KB`,
        null,
        "files"
      );
    } else {
      this.showToast("Invalid packet size", "warning");
    }
    this.dismissUploadSettings();
  }

  /**
   * Dismiss upload settings
   */
  dismissUploadSettings() {
    this.elements.uploadSettingsOverlay.classList.remove("show");
    this.elements.uploadSettingsPopup.classList.remove("show");
  }

  /**
   * üìù Log messages with emoji + timestamp
   */
  logToConsole(type, message, data = null, tab = "events") {
    this.state.messageCount++;
    this.elements.messageCount.textContent = this.state.messageCount;

    if (tab === "audio") {
      this.state.audioPacketCount++;
      this.elements.audioPackets.textContent = this.state.audioPacketCount;
    } else if (tab === "websocket") {
      this.state.wsMessageCount++;
      this.elements.wsMessages.textContent = this.state.wsMessageCount;
    } else if (tab === "files") {
      this.state.fileUploadCount++;
      this.elements.fileUploadCount.textContent = this.state.fileUploadCount;
    }

    const now = new Date();
    const timestamp = `${now.toLocaleTimeString()}.${now
      .getMilliseconds()
      .toString()
      .padStart(3, "0")}`;

    const logEntry = { timestamp, type, message, data };
    this.logs[tab].push(logEntry);

    if (this.state.currentTab === tab) {
      this.renderLogEntry(logEntry);
    }
  }

  /**
   * Render log entry
   */
  renderLogEntry(logEntry) {
    const logDiv = document.createElement("div");
    logDiv.className = `log-entry ${logEntry.type}`;

    let logData = "";
    if (logEntry.data) {
      logData = `<div class="log-data">${JSON.stringify(
        logEntry.data,
        null,
        2
      )}</div>`;
    }

    logDiv.innerHTML = `
            <span class="log-timestamp">${logEntry.timestamp}</span>
            <span class="log-type ${logEntry.type}">${logEntry.type}</span>
            <span class="log-message">${logEntry.message}</span>
            ${logData}
        `;

    this.elements.consoleContent.appendChild(logDiv);
    this.elements.consoleContent.scrollTop =
      this.elements.consoleContent.scrollHeight;
  }

  /**
   * Switch console tab
   */
  switchTab(tab) {
    this.state.currentTab = tab;
    document
      .querySelectorAll(".console-tab")
      .forEach((t) => t.classList.remove("active"));
    document.querySelector(`[data-tab="${tab}"]`).classList.add("active");

    this.elements.consoleContent.innerHTML = "";
    this.logs[tab].forEach((log) => this.renderLogEntry(log));
  }

  /**
   * Clear console
   */
  clearConsole() {
    this.logs[this.state.currentTab] = [];
    this.elements.consoleContent.innerHTML = "";

    if (this.state.currentTab === "events") {
      this.state.messageCount = 0;
      this.elements.messageCount.textContent = "0";
    } else if (this.state.currentTab === "audio") {
      this.state.audioPacketCount = 0;
      this.elements.audioPackets.textContent = "0";
    } else if (this.state.currentTab === "websocket") {
      this.state.wsMessageCount = 0;
      this.elements.wsMessages.textContent = "0";
    } else if (this.state.currentTab === "files") {
      this.state.fileUploadCount = 0;
      this.elements.fileUploadCount.textContent = "0";
    }

    this.logToConsole(
      "info",
      `${
        this.state.currentTab.charAt(0).toUpperCase() +
        this.state.currentTab.slice(1)
      } console cleared`,
      null,
      this.state.currentTab
    );
  }

  /**
   * Export logs
   */
  exportLogs() {
    const dataStr =
      "data:text/json;charset=utf-8," +
      encodeURIComponent(JSON.stringify(this.logs, null, 2));
    const downloadAnchorNode = document.createElement("a");
    downloadAnchorNode.setAttribute("href", dataStr);
    downloadAnchorNode.setAttribute(
      "download",
      `console-logs-${new Date().toISOString()}.json`
    );
    document.body.appendChild(downloadAnchorNode);
    downloadAnchorNode.click();
    downloadAnchorNode.remove();
    this.logToConsole("success", "Logs exported successfully", null, "events");
  }

  /**
   * üîî Show toast notification
   */
  showToast(message, type = "info") {
    const bgColors = {
      success: "linear-gradient(135deg, #00ff88, #00e676)",
      warning: "linear-gradient(135deg, #ffb800, #ffa726)",
      error: "linear-gradient(135deg, #ff4757, #ff3742)",
      info: "linear-gradient(135deg, #667eea, #764ba2)",
    };

    Toastify({
      text: message,
      duration: 3000,
      backgroundColor: bgColors[type] || bgColors.info,
    }).showToast();
  }

  /**
   * Handle keyboard events
   */
  handleKeydown(e) {
    if (e.key === "Escape") {
      if (this.elements.roomPopupOverlay.classList.contains("show")) {
        this.dismissRoomPopup();
      }
      if (this.elements.uploadSettingsOverlay.classList.contains("show")) {
        this.dismissUploadSettings();
      }
    }
  }

  /**
   * Update UI
   */
  updateUI() {
    this.updateActionButtons();
    this.updateStreamList();
  }

  /**
   * Cleanup
   */
  cleanup() {
    this.wsClient.disconnect();
    if (this.state.popupTimeout) {
      clearTimeout(this.state.popupTimeout);
    }
  }
}

// üöÄ Initialize application when DOM is loaded
document.addEventListener("DOMContentLoaded", () => {
  window.streamingApp = new StreamingApp();
});
