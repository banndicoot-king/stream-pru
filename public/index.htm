<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Live Audio Streaming</title>
    <style>
      body {
        display: flex;
        height: 100vh;
        margin: 0;
        padding: 0;
      }
      .stream-list {
        width: 250px;
        background-color: #f0f0f0;
        padding: 10px;
        overflow-y: auto;
      }
      h1 {
        margin-top: 0;
      }
      select {
        width: 100%;
        padding: 10px;
        margin-bottom: 20px;
        border-radius: 5px;
      }
      .audio-player-container {
        flex-grow: 1;
        background-color: #fff;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 20px;
      }
      audio {
        display: none; /* Hide the audio controls */
      }
    </style>
  </head>
  <body>
    <div class="stream-list">
      <h1>Live Audio Streaming</h1>
      <h2>Available Streams:</h2>
      <select id="streamSelect">
        <option value="">Select a stream</option>
      </select>
    </div>

    <div class="audio-player-container">
      <audio id="player" autoplay></audio>
    </div>

    <script>
      const ws = new WebSocket("ws://192.9.200.216:3031/");
      const streamList = document.getElementById("streamSelect");
      const audioElement = document.getElementById("player");

      let currentStream = null;
      let mediaSource = null;
      let sourceBuffer = null;
      let audioQueue = []; // Queue for audio chunks
      let isBuffering = false; // Prevent appending while buffering

      ws.onopen = () => {
        console.log("WebSocket connection established");
        ws.send(
          JSON.stringify({
            type: "register-user",
            id: Math.random().toString(36).substr(2, 9),
            name: "test",
          })
        );
      };

      ws.onmessage = (event) => {
        const message = JSON.parse(event.data);

        if (message.type === "update-streams") {
          updateStreamList(message.streams);
        } else if (
          message.type === "audio-chunk" &&
          message.roomId === currentStream
        ) {
          console.log("Received audio chunk", message.chunk.data.length);
          handleAudioChunk(message.chunk);
        }
      };

      ws.onerror = (error) => {
        console.error("WebSocket error:", error);
      };

      ws.onclose = () => {
        console.log("WebSocket connection closed");
      };

      // Update the list of available streams
      const updateStreamList = (streams) => {
        streamList.innerHTML = "<option value=''>Select a stream</option>";
        streams.forEach(({ id, name }) => {
          const option = document.createElement("option");
          option.value = id;
          option.textContent = name;
          streamList.appendChild(option);
        });
      };

      // Handle stream selection
      streamList.addEventListener("change", () => {
        const selectedStream = streamList.value;
        if (currentStream !== selectedStream) {
          stopStreaming();
          currentStream = selectedStream;
          if (currentStream) {
            startStreaming();
          }
        }
      });

      // Start streaming function
      const startStreaming = () => {
        if (!currentStream || ws.readyState !== WebSocket.OPEN) return;

        // Create a new MediaSource
        if (mediaSource) {
          mediaSource.endOfStream();
        }
        mediaSource = new MediaSource();
        audioElement.src = URL.createObjectURL(mediaSource);

        mediaSource.addEventListener("sourceopen", () => {
          sourceBuffer = mediaSource.addSourceBuffer("audio/mpeg");
          sourceBuffer.addEventListener("updateend", () => {
            if (!isBuffering && audioQueue.length > 0) {
              appendToBuffer();
            }
          });
        });

        // Ensure playback starts only after setting the source
        audioElement.oncanplay = () => {
          audioElement.play().catch((err) => {
            console.error("Error during playback:", err);
          });
        };

        // Join the selected stream
        ws.send(JSON.stringify({ type: "join-room", roomId: currentStream }));
        console.log("Listening to stream:", currentStream);
      };

      // Handle incoming audio chunks
      const handleAudioChunk = (chunkBase64) => {
        const chunk = new Uint8Array(chunkBase64.data);
        audioQueue.push(chunk);

        if (!sourceBuffer.updating && !isBuffering) {
          appendToBuffer();
        }
      };

      // Append audio chunks to the sourceBuffer
      const appendToBuffer = () => {
        if (audioQueue.length > 0 && sourceBuffer && !sourceBuffer.updating) {
          const chunk = audioQueue.shift();
          isBuffering = true;
          sourceBuffer.appendBuffer(chunk);
          isBuffering = false;
        }
      };

      // Stop streaming and reset media source
      const stopStreaming = () => {
        if (currentStream) {
          ws.send(
            JSON.stringify({ type: "leave-room", roomId: currentStream })
          );
          currentStream = null;
        }
        resetMediaSource();
      };

      const resetMediaSource = () => {
        if (mediaSource) {
          mediaSource.endOfStream();
          mediaSource = null;
        }
      };

      window.addEventListener("beforeunload", () => {
        if (ws.readyState === WebSocket.OPEN) {
          ws.close();
        }
      });
    </script>
  </body>
</html>
